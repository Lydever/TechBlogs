<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Set 与Map 数据结构</title>
</head>
<body>
<script>
  /**
   * ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
   * 通过add方法向set结构加入成员，通过size() 获取成员长度
   */

const s = new Set();
[1,2,2,3,4,5,5,6,7,8].forEach(item => s.add(item))

  for (let i of s) {
    console.log(i)
  }

  // Array.from可以将Set 结构专为数组
  const items = new Set([1,2,3,4,5]);
  const array = Array.from(items)

  // 去除数组重复成员的方法
  // [...new Set(array)]
  //去除字符串里面的重复字符串
  // [...new Set('abdjfjdd')].join('') // "abdfj\

  // 向Set加入值得时候不会发送类型转换，所以5和"5"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。
  let set = new Set();
  let a = NaN;
  let b = NaN;
  set.add(a);
  set.add(b);
  set  // Set {NaN}

  /**
   * 上面代码向 Set 实例添加了两次NaN，但是只会加入一个。这表明，在 Set 内部，两个NaN是相等的。
   另外，两个对象总是不相等的。
   */
  let set = new Set();
  set.add({});
  set.size // 1
  set.add({});
  set.size // 2

  // set 的遍历操作：四个遍历操作
  // set.prototype.keys() 返回键名的遍历器
  // set.prototype.values() 返回键值的遍历器
  // set.prototype.entries() 返回键值对的遍历器
  // set.prototype.forEach() 反悔 回调函数的遍历器

  let set = new Set(['res', 'green', 'blue']);
  for (let item of set.keys()) {
    console.log(item)
  }
  // red
  // green
  // blue

  for (let item of set.values()) {
    console.log(item)
  }
  // red
  // green
  // blue
  for (let item of set.entries()) {
    console.log(item)
  }
  // ['red', 'red']
  // ['green', 'green']
  // ['blue', 'blue']

  // forEach
  let set = new Set([1,4,9]);
  set.forEach((val,key) => {
    console.log(key + ":" +val)
  })
  // 1:1
  // 4:4
  // 9:9

  // let arr = [3,4,5,6,5]
  let unique = [...new Set(arr)]
  /**
   * Map
   */
  const map = new Map([
    ['name','张三'],
    ['title', 'Author']
  ]);
  map.size //2
  map.has('name') // true
  map.get('name') // 张三
  map.has('title') // true
  map.get('title') // 'Author'

  const map = new Map();
  items.forEach(([key,val]) => map.set(key,val))

  const set = new Set([
    ['info',1],
    ['suby',2]
  ])
  const ml = new Map(set);
  ml.get('info') // 1
  const m2 = new Map([['sub',3]])
  const m3 = new Map(m2);
  m3.get('info')

  let map = new  Map();
  map.set('foo', true);
  map.set('bar', false);
  map.size // 2
  map.clear()
  map.size // 0

  const map = new Map([
    ['f','no'],
    ['t','true']
  ])

  for (let key of map.keys()) {
    console.log(key)
  }

  for (let val of map.values()) {
    console.log(val)
  }

  for (let item of map.entries()) {
    console.log(item[0], item[1])
  }

  for (let [key,value] of map.entries()) {
    console.log(key, value);
  }

  // Map专为数组
  const mMap = new Map([[true,2],[{foo:3},['acvv']]])
  // [...mMap]

  // Map 转为对象
  const mapToObj = (strMap) => {
    let obj = Object.create(null);
    for (let [k,v] of strMap) {
      obj[k] = v;
    }
    return obj;
  }

  // 对象转为Map
  // 2. 对象转Map 可以通过Object.entries()
  let obj = {"a":1, "b":2};
  let map = new Map(Object.entries(obj))
  // 3.
  const objToMap = (obj) => {
    let strMap = new Map();
    for (let k of Object.keys(obj)) {
      strMap.set(k, obj[k])
    }
    return strMap
  }


</script>
</body>
</html>
